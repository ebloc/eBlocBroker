#!/usr/bin/env python3
import os
import re
import subprocess
import sys
import time
from io import StringIO
from typing import Tuple

from config import env, logging
from lib import _try, compress_folder, run, silent_remove
from startup import bp  # noqa: F401
from utils import _colorize_traceback, log, untar


def is_hash_exists_online(ipfs_hash, attempts):
    logging.info(f"Attempting to check IPFS file {ipfs_hash}")
    for attempt in range(attempts):
        try:
            timeout_duration = "300"  # wait max 5 minutes
            ipfs_stat = run(["timeout", timeout_duration, "ipfs", "object", "stat", ipfs_hash])
            log(f"attemt={attempt}\n{ipfs_stat}", "yellow")
            for item in ipfs_stat.split("\n"):
                if "CumulativeSize" in item:
                    cumulative_size = item.strip().split()[1]
            return True, ipfs_stat, int(cumulative_size)
        except:
            logging.error(f"E: Failed to find IPFS file: {ipfs_hash}")
            return False, None, None
    return False, None, None


def is_hash_locally_cached(ipfs_hash) -> bool:
    """Run ipfs --offline refs -r or ipfs --offline block stat etc even if your normal daemon is running.
       With that you can check if something is available locally or no."""
    try:
        subprocess.check_output(["ipfs", "--offline", "block", "stat", ipfs_hash], stderr=subprocess.DEVNULL)
        return True
    except Exception:
        return False


def get(ipfs_hash, path, is_storage_paid):
    output = run(["ipfs", "get", ipfs_hash, f"--output={path}"])
    logging.info(output)

    if is_storage_paid:
        # pin downloaded ipfs hash if storage is paid
        output = subprocess.check_output(["ipfs", "pin", "add", ipfs_hash]).decode("utf-8").rstrip()
        logging.info(output)


def pin(ipfs_hash) -> bool:
    return run(["ipfs", "pin", "add", ipfs_hash])


def decrypt_using_gpg(gpg_file, extract_target):
    if not os.path.isfile(f"{gpg_file}.gpg"):
        os.symlink(gpg_file, f"{gpg_file}.gpg")

    gpg_file_link = f"{gpg_file}.gpg"
    tar_file = f"{gpg_file}.tar.gz"

    """cmd:
    gpg --output={tar_file} --pinentry-mode loopback \
        --passphrase-file=f"{env.LOG_PATH}/gpg_pass.txt" \
        --decrypt {gpg_file_link}
    """
    cmd = [
        "gpg",
        "--batch",
        "--yes",
        f"--output={tar_file}",
        "--pinentry-mode",
        "loopback",
        f"--passphrase-file={env.LOG_PATH}/.gpg_pass.txt",
        "--decrypt",
        gpg_file_link,
    ]

    try:
        run(cmd)
    except:
        _colorize_traceback()
        raise
    finally:
        os.unlink(gpg_file_link)
        silent_remove(gpg_file)  # Downloaded file is removed

    try:
        log("mlck decrypt: SUCCESS", "green")
        untar(tar_file, extract_target)
    except:
        logging.error("E: Could not extract the given tar file")
        raise
    finally:
        cmd = None
        silent_remove(tar_file)


def gpg_encrypt(provider_gpg_finderprint, target):
    is_delete = False
    if os.path.isdir(target):
        try:
            *_, target_compressed = compress_folder(target)
            is_delete = True
        except:
            _colorize_traceback()
            sys.exit()

    encrypted_file_target = f"{target_compressed}.gpg"
    if os.path.isfile(encrypted_file_target):
        log(f"{encrypted_file_target} is already created.", "green")
        return encrypted_file_target

    try:
        run(
            [
                "gpg",
                "--batch",
                "--yes",
                "--recipient",
                provider_gpg_finderprint,
                "--output",
                encrypted_file_target,
                "--encrypt",
                target_compressed,
            ]
        )
        return encrypted_file_target
    except:
        _colorize_traceback()
        raise
    finally:
        if is_delete:
            silent_remove(target_compressed)


def get_cumulative_size(source_code_hash):
    cmd = ["ipfs", "object", "stat", source_code_hash]
    is_ipfs_hash_exist = run(cmd)
    for item in is_ipfs_hash_exist.split("\n"):
        if "CumulativeSize" in item:
            return item.strip().split()[1]


def get_parent_hash(ipfs_hash) -> Tuple[bool, str]:
    """Parses output of 'ipfs add -r path --only-hash' cmd and obtain its parent folder's hash.

    Args:
    ipfs_hash: String generated by the 'ipfs add -r path --only-hash'

    * Command: echo ipfs_hash | tail -n1 | awk '{print $2}'
    * Returns IPFS hash of the parent directory.
    """
    p1 = subprocess.Popen(["echo", ipfs_hash], stdout=subprocess.PIPE)
    p2 = subprocess.Popen(["tail", "-n1"], stdin=p1.stdout, stdout=subprocess.PIPE)
    p1.stdout.close()
    p3 = subprocess.Popen(["awk", "{print $2}"], stdin=p2.stdout, stdout=subprocess.PIPE)
    p2.stdout.close()
    ipfs_hash = p3.communicate()[0].decode("utf-8").strip()
    logging.info(f"ipfs_hash={ipfs_hash}")
    return ipfs_hash


def add(path: str, is_hidden=False):
    """Add file or folder into ipfs.

    :param is_hidden: boolean if it is true hidden files/foders are included such as .git
    """
    if os.path.isdir(path):
        if is_hidden:
            # include files that are hidden such as .git/. Only takes effect on recursive add
            cmd = ["ipfs", "add", "-r", "--hidden", "--quieter", "--progress", "--local", path]
        else:
            cmd = ["ipfs", "add", "-r", "--quieter", "--progress", "--local", path]
    elif os.path.isfile(path):
        cmd = ["ipfs", "add", path]
    else:
        logging.error("E: Requested path does not exist")
        raise

    for attempt in range(10):
        try:
            result_ipfs_hash = run(cmd)
            if os.path.isfile(path):
                result_ipfs_hash = result_ipfs_hash.split(" ")[1]

            if not result_ipfs_hash:
                logging.error(f"E: Generated new hash returned empty. Trying again. Try count: {attempt}")
                time.sleep(5)  # wait 5 seconds for next retry to upload again
        except:
            logging.error(f"E: Generated new hash returned empty. Trying again. Try count: {attempt}")
            time.sleep(5)
        else:  # success
            break
    else:  # failed all the attempts - abort
        sys.exit(1)

    return result_ipfs_hash


def get_only_ipfs_hash(path) -> Tuple[bool, str]:
    """Gets only chunk and hash of a given path, do not write to disk.

    Args:
        path: Path of a folder or file

    Returns string that contains the ouput of the run commad.
    """
    if os.path.isdir(path):
        cmd = ["ipfs", "add", "-r", path, "--only-hash", "-H"]
    elif os.path.isfile(path):
        cmd = ["ipfs", "add", path, "--only-hash"]
    else:
        logging.error("E: Requested path does not exist.")
        return False, None
    try:
        output = run(cmd)
        result_ipfs_hash = _try(lambda: get_parent_hash(output))
        return True, result_ipfs_hash
    except Exception:
        return False, None


def connect_to_bootstrap_node():
    cmd = ["ipfs", "bootstrap", "list"]
    output = run(cmd, is_print_trace=False)
    s = StringIO(output)
    peer_address = None
    for line in s:
        if re.search(r"/ip4/", line) is not None:
            peer_address = line
            break

    cmd = ["ipfs", "swarm", "connect", peer_address]
    return run(cmd, is_print_trace=False)
