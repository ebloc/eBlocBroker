#!/usr/bin/env python3
import os
import re
import subprocess
import sys
import time
from io import StringIO
from typing import Tuple

from config import logging
from lib import _try, compress_folder, run, silent_remove
from startup import bp  # noqa: F401
from utils import log


def is_hash_exists_online(ipfs_hash, attempt_count):
    logging.info(f"Attempting to check IPFS file {ipfs_hash}")
    for attempt in range(attempt_count):
        try:
            timeout_duration = "300"  # wait max 5 minutes
            ipfs_stat = run(["timeout", timeout_duration, "ipfs", "object", "stat", ipfs_hash])
            log(ipfs_stat, "yellow")
            for item in ipfs_stat.split("\n"):
                if "CumulativeSize" in item:
                    cumulative_size = item.strip().split()[1]
            return True, ipfs_stat, int(cumulative_size)
        except:
            logging.error(f"E: Failed to find IPFS file: {ipfs_hash}")
            return False, None, None
    else:
        return False, None, None


def is_hash_locally_cached(ipfs_hash) -> bool:
    """Run ipfs --offline refs -r or ipfs --offline block stat etc even if your normal daemon is running.
       With that you can check if something is available locally or no."""
    try:
        subprocess.check_output(["ipfs", "--offline", "block", "stat", ipfs_hash], stderr=subprocess.DEVNULL)
        return True
    except Exception:
        return False


def get(ipfs_hash, path, is_storage_paid):
    output = run(["ipfs", "get", ipfs_hash, f"--output={path}"])
    logging.info(output)

    if is_storage_paid:
        # pin downloaded ipfs hash if storage is paid
        output = subprocess.check_output(["ipfs", "pin", "add", ipfs_hash]).decode("utf-8").rstrip()
        logging.info(output)


def pin(ipfs_hash) -> bool:
    return run(["ipfs", "pin", "add", ipfs_hash])


def mlck_encrypt(provider_minilock_id, mlck_pass, target):
    is_delete = False
    if os.path.isdir(target):
        tar_hash, target_compressed = compress_folder(target)
        is_delete = True

    try:
        run(["mlck", "encrypt", "-f", target_compressed, provider_minilock_id, f"--passphrase={mlck_pass}"])
        return f"{target_compressed}.minilock"
    except:
        raise
    finally:
        if is_delete:
            silent_remove(target_compressed)


def get_cumulative_size(source_code_hash):
    cmd = ["ipfs", "object", "stat", source_code_hash]
    is_ipfs_hash_exist = run(cmd)
    for item in is_ipfs_hash_exist.split("\n"):
        if "CumulativeSize" in item:
            return item.strip().split()[1]


def get_parent_hash(ipfs_hash) -> Tuple[bool, str]:
    """Parses output of 'ipfs add -r path --only-hash' cmd and obtain its parent folder's hash.

    Args:
    ipfs_hash: String generated by the 'ipfs add -r path --only-hash'

    * Command: echo ipfs_hash | tail -n1 | awk '{print $2}'
    * Returns IPFS hash of the parent directory.
    """
    p1 = subprocess.Popen(["echo", ipfs_hash], stdout=subprocess.PIPE)
    p2 = subprocess.Popen(["tail", "-n1"], stdin=p1.stdout, stdout=subprocess.PIPE)
    p1.stdout.close()
    p3 = subprocess.Popen(["awk", "{print $2}"], stdin=p2.stdout, stdout=subprocess.PIPE)
    p2.stdout.close()
    ipfs_hash = p3.communicate()[0].decode("utf-8").strip()
    logging.info(f"ipfs_hash={ipfs_hash}")
    return ipfs_hash


def add(path: str, is_hidden=False):
    """Add file or folder into ipfs.

    :param is_hidden: boolean if it is true hidden files/foders are included such as .git
    """
    if os.path.isdir(path):
        if is_hidden:
            # include files that are hidden such as .git/. Only takes effect on recursive add
            cmd = ["ipfs", "add", "-r", "--hidden", "--quieter", "--progress", "--local", path]
        else:
            cmd = ["ipfs", "add", "-r", "--quieter", "--progress", "--local", path]
    elif os.path.isfile(path):
        cmd = ["ipfs", "add", path]
    else:
        logging.error("E: Requested path does not exist")
        raise

    for attempt in range(10):
        try:
            result_ipfs_hash = run(cmd)
            if os.path.isfile(path):
                result_ipfs_hash = result_ipfs_hash.split(" ")[1]

            if not result_ipfs_hash:
                logging.error(f"E: Generated new hash returned empty. Trying again. Try count: {attempt}")
                time.sleep(5)  # wait 5 seconds for next retry to upload again
        except:
            logging.error(f"E: Generated new hash returned empty. Trying again. Try count: {attempt}")
            time.sleep(5)
        else:  # success
            break
    else:  # failed all the attempts - abort
        sys.exit(1)

    return True, result_ipfs_hash


def get_only_ipfs_hash(path) -> Tuple[bool, str]:
    """Gets only chunk and hash of a given path, do not write to disk.

    Args:
        path: Path of a folder or file

    Returns string that contains the ouput of the run commad.
    """
    if os.path.isdir(path):
        cmd = ["ipfs", "add", "-r", path, "--only-hash", "-H"]
    elif os.path.isfile(path):
        cmd = ["ipfs", "add", path, "--only-hash"]
    else:
        logging.error("E: Requested path does not exist.")
        return False, None
    try:
        output = run(cmd)
        result_ipfs_hash = _try(lambda: get_parent_hash(output))
        return True, result_ipfs_hash
    except Exception:
        return False, None


def connect_to_bootstrap_node():
    cmd = ["ipfs", "bootstrap", "list"]
    output = run(cmd, is_print_trace=False)
    s = StringIO(output)
    peer_address = None
    for line in s:
        if re.search(r"/ip4/", line) is not None:
            peer_address = line
            break

    cmd = ["ipfs", "swarm", "connect", peer_address]
    return run(cmd, is_print_trace=False)
